import os
import math
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.patches import Polygon
import torch
import torch.nn as nn
import torch.optim as optim
from torch.distributions import Normal
import gymnasium as gym
from gymnasium import spaces

os.makedirs('outputs', exist_ok=True)

class StraightLineFishEnv(gym.Env):
    """æ”¹è¿›ç‰ˆï¼šå¼ºåŒ–çº åæœºåˆ¶"""
    metadata = {"render_modes": ["human"], "render_fps": 30}

    def __init__(self, num_segments=5, body_length=0.8):
        super().__init__()

        # Geometry - çººé”¤å‹èº«ä½“
        self.num_segments = int(num_segments)
        self.segment_ratios = [0.15, 0.20, 0.18, 0.20, 0.27][:self.num_segments]
        self.segment_lengths = [r * body_length for r in self.segment_ratios]
        self.body_length = sum(self.segment_lengths)

        self.body_width_ratios = self._compute_width_ratios()
        self.max_body_width = 0.14
        self.center_of_mass_offset = self.body_length / 2.0

        # Wave parameters
        self.frequency = 2.0
        self.base_amplitude = 0.35
        self.wave_length = 0.8 * self.body_length

        # Dynamics parameters
        self.dt = 0.05
        self.max_steps = 800
        self.mass = 1.0
        self.inertia = 0.2
        self.water_drag_linear = 1.5
        self.angular_damping = 1.2
        self.thrust_k_forward = -2.5
        self.thrust_k_side = 1.0
        self.tail_lever = self.body_length * 0.8

        # Limits
        self.max_speed = 1.5
        self.max_omega = 2.0

        # Action & Observation
        self.action_space = spaces.Box(low=-1.0, high=1.0, shape=(2,), dtype=np.float32)
        # å¢å¼ºè§‚æµ‹ï¼šæ·»åŠ å†å²åå·®ä¿¡æ¯
        self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(13,), dtype=np.float32)

        # ç›®æ ‡ç›´çº¿
        self.target_line_x = 0.0

        # æ–°å¢ï¼šè·Ÿè¸ªåå·®å†å²
        self.prev_lateral_deviation = 0.0
        self.time_in_perfect_zone = 0

        self.reset()

    def _compute_width_ratios(self):
        """çººé”¤å½¢å®½åº¦åˆ†å¸ƒ"""
        if self.num_segments == 5:
            return [0.5, 0.85, 0.75, 0.6, 0.25]
        elif self.num_segments == 4:
            return [0.6, 1.0, 0.7, 0.3]
        else:
            return [1.0 - i/(self.num_segments-1) * 0.75 for i in range(self.num_segments)]

    def _get_body_center_global(self):
        """è®¡ç®—èº«ä½“ä¸­å¿ƒçš„å…¨å±€åæ ‡"""
        cos_o, sin_o = math.cos(self.orientation), math.sin(self.orientation)
        center_offset_vec = self.center_of_mass_offset * np.array([cos_o, sin_o])
        return self.position + center_offset_vec

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)

        # å¢åŠ åˆå§‹æ‰°åŠ¨èŒƒå›´ï¼Œè®©æ™ºèƒ½ä½“å­¦ä¼šä»æ›´å¤§åå·®æ¢å¤
        x_offset = np.random.uniform(-0.3, 0.3)
        self.position = np.array([x_offset, 0.0])

        angle_offset = np.random.uniform(-0.2, 0.2)
        self.orientation = math.pi / 2.0 + angle_offset

        self.velocity = np.zeros(2)
        self.omega = 0.0
        self.wave_phase = 0.0
        self.step_count = 0

        self.body_center = self._get_body_center_global()
        self.trajectory = [self.body_center.copy()]

        # é‡ç½®è·Ÿè¸ªå˜é‡
        self.prev_lateral_deviation = self.body_center[0] - self.target_line_x
        self.time_in_perfect_zone = 0

        lateral_deviation = self.prev_lateral_deviation
        self.lateral_history = [lateral_deviation]*5  # é•¿åº¦å›ºå®š5

        return self._get_obs(), {}

    def _get_obs(self):
        """å¢å¼ºè§‚æµ‹ç©ºé—´ - åŒ…å«çº åä¿¡æ¯"""
        center_pos = self._get_body_center_global()

        # æ¨ªå‘åå·®
        lateral_deviation = center_pos[0] - self.target_line_x

        # æœå‘è¯¯å·®
        target_orientation = -math.pi / 2.0
        orientation_error = self.orientation - target_orientation
        orientation_error = (orientation_error + math.pi) % (2 * math.pi) - math.pi

        # å‰è¿›æ–¹å‘
        forward_dir = np.array([math.cos(self.orientation), math.sin(self.orientation)])
        y_direction = np.array([0.0, 1.0])
        alignment = np.dot(forward_dir, y_direction)

        # æ–°å¢ï¼šåå·®å˜åŒ–ç‡ï¼ˆåˆ¤æ–­æ˜¯å¦åœ¨çº åï¼‰
        deviation_change = lateral_deviation - self.prev_lateral_deviation

        # æ–°å¢ï¼šæ˜¯å¦åœ¨perfect zoneå†…
        in_perfect_zone = 1.0 if abs(lateral_deviation) < 0.1 else 0.0

        obs = np.array([
            lateral_deviation,
            orientation_error,
            self.velocity[0],
            self.velocity[1],
            self.omega,
            alignment,
            deviation_change,
            in_perfect_zone,
            *self.lateral_history  # æœ€è¿‘5æ­¥å†å²åå·®
        ], dtype=np.float32)

        return obs

    def _body_wave_angles(self, amplitude, bias):
        """è®¡ç®—å…³èŠ‚è§’"""
        joint_angles = []
        omega = 2 * np.pi * self.frequency
        wave_number = 2 * np.pi / self.wave_length

        current_s_pos = 0.0
        for i in range(self.num_segments):
            current_s_pos += self.segment_lengths[i] / self.body_length
            s = current_s_pos

            env_amp = amplitude * (s ** 2)
            bias_term = bias * (i / max(1, (self.num_segments - 1))) * 0.5

            phase = wave_number * s * self.body_length
            angle = env_amp * np.sin(phase + omega * self.wave_phase) + bias_term
            joint_angles.append(angle)

        return np.array(joint_angles)

    def _body_positions(self, joint_angles):
        """è®¡ç®—é±¼ä½“å„å…³èŠ‚ä½ç½®"""
        positions = [self.position.copy()]
        current_angle = self.orientation

        for i, a in enumerate(joint_angles):
            current_angle += a
            L = self.segment_lengths[i]
            nxt = positions[-1] + L * np.array([math.cos(current_angle), math.sin(current_angle)])
            positions.append(nxt)

        return np.array(positions)

    def step(self, action):
        self.step_count += 1
        a = np.clip(action, -1.0, 1.0)
        amp_scale = float(a[0])
        bias = float(a[1])

        # Warm-start heuristic: å‰30æ­¥å¿«é€Ÿä¾§å‘æ¢ç´¢
        center_pos = self._get_body_center_global()
        lateral_deviation = center_pos[0] - self.target_line_x
        if self.step_count <= 30:
            bias = -np.sign(lateral_deviation) * 0.5  # å‘ä¸­å¿ƒçº¿æ–½åŠ side-force
            amp_scale = 0.2  # å°å¹…æ³¢åŠ¨

        # æ˜ å°„åŠ¨ä½œåˆ°å¹…å€¼
        amplitude = self.base_amplitude * (1.0 + 0.9 * amp_scale)
        amplitude = max(0.01, amplitude)

        # æ›´æ–°æ³¢ç›¸ä½
        self.wave_phase += self.dt

        # è®¡ç®—å°¾éƒ¨è¿åŠ¨äº§ç”Ÿçš„åŠ›
        amp_tail = amplitude * (1.0 ** 2)
        forward_thrust = self.thrust_k_forward * (amp_tail ** 2)
        bias_scale = 0.6
        side_force = self.thrust_k_side * amp_tail * (bias * bias_scale)

        # å…¨å±€æ–¹å‘å‘é‡
        forward_dir = np.array([math.cos(self.orientation), math.sin(self.orientation)])
        lateral_dir = np.array([-forward_dir[1], forward_dir[0]])
        F = forward_thrust * forward_dir + side_force * lateral_dir

        # è®¡ç®—å°¾éƒ¨ä½ç½®ï¼ˆæ›´ç‰©ç†ï¼‰
        joint_angles = self._body_wave_angles(amplitude, bias)
        positions = self._body_positions(joint_angles)
        tail_pos = positions[-1]  # å…¨å±€åæ ‡å°¾ç‚¹
        # è´¨å¿ƒï¼ˆbody_centerï¼‰å·²ç»æœ‰
        r_tail = tail_pos - self.body_center  # ä»è´¨å¿ƒæŒ‡å‘å°¾éƒ¨çš„å‘é‡

        # 2D åŠ›çŸ© = r x F (zåˆ†é‡)
        torque_from_tail = r_tail[0] * F[1] - r_tail[1] * F[0]

        # è§’é˜»å°¼ï¼ˆé˜»å°¼é¡¹ï¼‰å’Œè¢«åŠ¨æ¢å¤é¡¹ï¼ˆå¯é€‰ï¼‰
        passive_restore_k = 0.0  # è‹¥æƒ³è¦è½»å¾®è¢«åŠ¨æ ¡æ­£ï¼Œå¯è®¾ç½®ä¸ºå°å€¼ 0.1~0.5
        restore_torque = -passive_restore_k * (self.orientation - math.pi/2.0)

        torque = torque_from_tail + restore_torque - self.angular_damping * self.omega

        # æ°´é˜»åŠ›ï¼šé‡‡ç”¨çº¿æ€§+äºŒæ¬¡é˜»åŠ›ç»„åˆï¼ˆæ›´ç¨³å®šï¼‰
        v = self.velocity
        v_norm = np.linalg.norm(v)
        linear_drag = self.water_drag_linear * v
        quad_drag = 0.5 * 1.0 * v * v_norm  # 0.5 * rho*A çš„åˆå¹¶é¡¹ï¼Œ1.0æ˜¯å¯è°ƒç³»æ•°
        drag = linear_drag + quad_drag

        acc = (F - drag) / self.mass
        self.velocity += acc * self.dt

        # é™é€Ÿ
        speed = np.linalg.norm(self.velocity)
        if speed > self.max_speed:
            self.velocity = (self.velocity / speed) * self.max_speed

        ang_acc = torque / self.inertia
        self.omega += ang_acc * self.dt
        self.omega = float(np.clip(self.omega, -self.max_omega, self.max_omega))

        self.position = self.position + self.velocity * self.dt
        self.orientation += self.omega * self.dt
        self.orientation = (self.orientation + math.pi) % (2*math.pi) - math.pi

        # æ›´æ–°èº«ä½“ä¸­å¿ƒä¸è½¨è¿¹
        self.body_center = self._get_body_center_global()
        self.trajectory.append(self.body_center.copy())


        # è®¡ç®—å¥–åŠ±
        reward = self._compute_reward(amplitude, bias)

        # åˆæœŸå¿«é€Ÿçº åå¥–åŠ±
        if self.step_count <= 30:
            deviation_reduction = abs(self.prev_lateral_deviation) - abs(lateral_deviation)
            r_initial_correction = 20.0 * np.clip(deviation_reduction, 0.0, None)
            reward += r_initial_correction
        self.prev_lateral_deviation = lateral_deviation

        terminated = self.step_count >= self.max_steps
        truncated = False

        info = {'amp': amplitude, 'bias': bias}
        return self._get_obs(), float(reward), terminated, truncated, info

    def _compute_reward(self, amplitude, bias):
        """æ”¹è¿›çš„å¥–åŠ±å‡½æ•° - å¼ºåŒ–çº åå’Œå±‚æ¬¡åŒ–æ¿€åŠ±"""
        center_pos = self.body_center

        # æ¨ªå‘åå·®
        lateral_deviation = center_pos[0] - self.target_line_x

        # æœå‘è¯¯å·®
        target_orientation = -math.pi / 2.0
        orientation_error = abs(self.orientation - target_orientation)
        if orientation_error > math.pi:
            orientation_error = 2 * math.pi - orientation_error

        # é€Ÿåº¦åˆ†è§£
        forward_dir = np.array([math.cos(self.orientation), math.sin(self.orientation)])
        y_direction = np.array([0.0, 1.0])
        y_speed = self.velocity[1]
        x_speed = self.velocity[0]
        alignment = np.dot(forward_dir, y_direction)

        # åå·®å˜åŒ–ï¼ˆåˆ¤æ–­æ˜¯å¦åœ¨çº åï¼‰
        deviation_change = lateral_deviation - self.prev_lateral_deviation
        is_correcting = (abs(lateral_deviation) > 0.05 and
                        np.sign(lateral_deviation) != np.sign(deviation_change))

        # æ›´æ–°å†å²
        self.prev_lateral_deviation = lateral_deviation

        # ========= æ”¹è¿›çš„åˆ†å±‚å¥–åŠ± =========

        # === ç¬¬1å±‚ï¼šåŸºç¡€çº¦æŸï¼ˆæ€»æ˜¯ç”Ÿæ•ˆï¼‰===

        # 1. æ¨ªå‘åå·® - ä½¿ç”¨åˆ†æ®µæƒ©ç½š
        if abs(lateral_deviation) < 0.1:
            # Perfect Zone: å°æƒ©ç½š
            r_lateral_pos = 1.0 * (lateral_deviation ** 2)
        elif abs(lateral_deviation) < 0.3:
            # Warning Zone: ä¸­ç­‰æƒ©ç½š
            r_lateral_pos = -5.0 * (lateral_deviation ** 2)
        else:
            # Danger Zone: å¤§æƒ©ç½š
            r_lateral_pos = -15.0 * (lateral_deviation ** 2)

        # å¢åŠ å‰å‡ æ­¥å¿«é€Ÿçº åå¥–åŠ±
        if self.step_count < 30:  # å‰30æ­¥ä¸ºâ€œå¿«é€Ÿå®šä½æœŸâ€
        # lateral_deviation ä»åˆå§‹å€¼å‡å° -> å¥–åŠ±
            deviation_reduction = abs(self.prev_lateral_deviation) - abs(lateral_deviation)
            r_initial_correction = 20.0 * np.clip(deviation_reduction, 0.0, None)
        else:
            r_initial_correction = 0.0

        # 2. æ¨ªå‘é€Ÿåº¦æƒ©ç½š
        r_lateral_vel = -25.0 * (x_speed ** 2)

        # 3. æœå‘æƒ©ç½š
        r_orientation = -25.0 * (orientation_error ** 2)

        # 4. è§’é€Ÿåº¦æƒ©ç½š
        r_omega = -15.0 * (self.omega ** 2)

        # === ç¬¬2å±‚ï¼šçº åæ¿€åŠ±ï¼ˆåç¦»æ—¶æ‰é‡è¦ï¼‰===

        # 5. çº åå¥–åŠ± - å½“åç¦»æ—¶ï¼Œå¦‚æœæ­£åœ¨æœæ­£ç¡®æ–¹å‘ä¿®æ­£ï¼Œç»™äºˆå¥–åŠ±
        # æ¨ªå‘é€Ÿåº¦æ–¹å‘å¯¹åå·®çš„å“åº”
        if is_correcting: # r_correction = 15.0 * (1.0 - abs(lateral_deviation) / 0.5) # è¶Šåç¦»å¥–åŠ±è¶Šå¤§
            r_correction = 15.0 * abs(deviation_change) * (1.0 - min(abs(lateral_deviation)/0.5, 1.0))
        else:
            r_correction = 0.0

        # === ç¬¬3å±‚ï¼šæ€§èƒ½å¥–åŠ±ï¼ˆåœ¨çº¦æŸæ»¡è¶³æ—¶æ‰ç”Ÿæ•ˆï¼‰===

        # 6. å‰è¿›å¥–åŠ± - åªæœ‰åœ¨åå·®è¾ƒå°æ—¶æ‰ç»™
        if abs(lateral_deviation) < 0.3:
            r_forward = 10.0 * max(0, y_speed)
        else:
            # r_forward = 10.0 * max(0, y_speed) * np.exp(-10*abs(lateral_deviation))  # å¤§åå·®æ—¶é™ä½å‰è¿›å¥–åŠ±
            r_forward = 10.0 * max(0, y_speed) * (1.0 - min(abs(lateral_deviation)/0.5, 1.0))

        # 7. æ–¹å‘å¯¹é½å¥–åŠ±
        r_alignment = 8.0 * max(0, alignment)

        # === ç¬¬4å±‚ï¼šç­–ç•¥å¼•å¯¼ ===

        # 8. biasæƒ©ç½š - ä½†åœ¨éœ€è¦çº åæ—¶æ”¾å®½
        if abs(lateral_deviation) > 0.15:
            # åç¦»è¾ƒå¤§æ—¶ï¼Œå…è®¸ä½¿ç”¨biasçº å
            r_bias_penalty = -5.0 * (bias ** 2)
        else:
            # åç¦»å°æ—¶ï¼Œå¼ºçƒˆæƒ©ç½šbias
            r_bias_penalty = -25.0 * (bias ** 2)

        # 9. èƒ½é‡æƒ©ç½š
        r_energy = -0.05 * ((amplitude - self.base_amplitude) ** 2)

        # 10. å­˜æ´»å¥–åŠ±
        r_alive = 0.01

        # === ç¬¬5å±‚ï¼šPerfect Zoneå¤§é¢å¥–åŠ± ===

        # 11. Perfect Zoneå¥–åŠ± - æŒç»­åœ¨å†…æ‰ç»™
        if abs(lateral_deviation) < 0.1:
            self.time_in_perfect_zone += 1
            # æŒç»­æ—¶é—´è¶Šé•¿ï¼Œå¥–åŠ±è¶Šé«˜
            r_perfect = 50.0 * np.exp(-15*abs(lateral_deviation))
        else:
            self.time_in_perfect_zone = 0
            r_perfect = 0.0

        # 12. é¢å¤–å¥–åŠ±ï¼šå®Œç¾çŠ¶æ€ï¼ˆæ‰€æœ‰æŒ‡æ ‡éƒ½ä¼˜ç§€ï¼‰
        if (abs(lateral_deviation) < 0.08 and
            abs(x_speed) < 0.05 and
            orientation_error < 0.15 and
            0.3 < y_speed < 1.0):
            r_excellence = 40.0
        else:
            r_excellence = 0.0

        # æ€»å¥–åŠ±
        total = (r_lateral_pos + r_lateral_vel + r_orientation + r_omega +
                 r_correction + r_forward + r_alignment + r_bias_penalty +
                 r_energy + r_alive + r_perfect + r_excellence + r_initial_correction)

        if not np.isfinite(total):
            total = -100.0
        return float(total)

    def get_trajectory(self):
        return np.array(self.trajectory)

    def get_body_segments(self):
        joint_angles = self._body_wave_angles(self.base_amplitude, 0.0)
        positions = self._body_positions(joint_angles)
        segments = []

        for i in range(len(positions)-1):
            p1, p2 = positions[i], positions[i+1]
            dirv = p2 - p1
            L = np.linalg.norm(dirv)
            if L < 1e-6:
                dirv = np.array([1.0, 0.0])
            else:
                dirv = dirv / L
            perp = np.array([-dirv[1], dirv[0]])

            width_ratio = self.body_width_ratios[i]
            width = self.max_body_width * width_ratio
            hw = width / 2.0

            corners = np.array([p1 + perp*hw, p1 - perp*hw, p2 - perp*hw, p2 + perp*hw])
            segments.append(corners)

        return segments, positions


class ActorCritic(nn.Module):
    def __init__(self, state_dim, action_dim, hidden_size=128):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(state_dim, hidden_size), nn.ReLU(),
            nn.Linear(hidden_size, hidden_size), nn.ReLU()
        )
        self.actor_mean = nn.Linear(hidden_size, action_dim)
        self.actor_log_std = nn.Parameter(torch.zeros(1, action_dim))
        self.critic = nn.Linear(hidden_size, 1)

        for m in self.net:
            if isinstance(m, nn.Linear):
                nn.init.orthogonal_(m.weight, gain=np.sqrt(2))
                nn.init.constant_(m.bias, 0.0)
        nn.init.orthogonal_(self.actor_mean.weight, gain=0.01)
        nn.init.constant_(self.actor_mean.bias, 0.0)
        nn.init.orthogonal_(self.critic.weight, gain=1.0)
        nn.init.constant_(self.critic.bias, 0.0)

    def forward(self, state):
        x = self.net(state)
        mean = torch.tanh(self.actor_mean(x))
        std = torch.exp(torch.clamp(self.actor_log_std, -20, 2))
        value = self.critic(x).squeeze(-1)
        return mean, std, value

    def get_action(self, state_np, deterministic=False):
        state = torch.FloatTensor(state_np).unsqueeze(0)
        mean, std, value = self.forward(state)
        if deterministic:
            action = mean
        else:
            dist = Normal(mean, std)
            action = dist.sample()
            action = torch.clamp(action, -1.0, 1.0)
        return action.detach().numpy()[0], value.detach().numpy()[0]


class PPOTrainer:
    def __init__(self, env, lr=3e-4, gamma=0.99, lam=0.95, clip=0.2, epochs=10, batch_size=64):
        self.env = env
        sdim = env.observation_space.shape[0]
        adim = env.action_space.shape[0]
        self.model = ActorCritic(sdim, adim, hidden_size=128)
        self.optim = optim.Adam(self.model.parameters(), lr=lr)
        self.gamma = gamma
        self.lam = lam
        self.clip = clip
        self.epochs = epochs
        self.batch_size = batch_size
        self.episode_rewards = []

    def train_episode(self):
        obs, _ = self.env.reset()
        states, actions, rewards, values, logps = [], [], [], [], []

        for step in range(self.env.max_steps):
            action, val = self.model.get_action(obs)
            s_t = torch.FloatTensor(obs).unsqueeze(0)
            mean, std, _ = self.model.forward(s_t)
            dist = Normal(mean, std)
            logp = dist.log_prob(torch.FloatTensor(action)).sum().item()

            next_obs, reward, done, truncated, info = self.env.step(action)
            states.append(obs)
            actions.append(action)
            rewards.append(reward)
            values.append(float(val))
            logps.append(logp)
            obs = next_obs
            if done or truncated:
                break

        self.episode_rewards.append(sum(rewards))

        # GAEè®¡ç®—
        advantages = []
        gae = 0.0
        values = values + [0.0]
        for t in reversed(range(len(rewards))):
            delta = rewards[t] + self.gamma * values[t+1] - values[t]
            gae = delta + self.gamma * self.lam * gae
            advantages.insert(0, gae)

        advantages = torch.FloatTensor(advantages)
        if len(advantages) == 0 or torch.isnan(advantages).any():
            return self.episode_rewards[-1]

        advantages = (advantages - advantages.mean()) / (advantages.std() + 1e-8)
        states_t = torch.FloatTensor(np.array(states))
        actions_t = torch.FloatTensor(np.array(actions))
        old_logps_t = torch.FloatTensor(np.array(logps))
        returns = advantages + torch.FloatTensor([values[i] for i in range(len(advantages))])

        dataset = torch.utils.data.TensorDataset(states_t, actions_t, advantages, old_logps_t, returns)
        loader = torch.utils.data.DataLoader(dataset, batch_size=min(self.batch_size, len(states_t)), shuffle=True)

        for _ in range(self.epochs):
            for s_batch, a_batch, adv_batch, old_log_batch, ret_batch in loader:
                mean, std, valpred = self.model.forward(s_batch)
                if torch.isnan(mean).any() or torch.isnan(std).any():
                    continue

                dist = Normal(mean, std)
                new_logp = dist.log_prob(a_batch).sum(dim=-1)
                ratio = torch.exp(new_logp - old_log_batch)

                surr1 = ratio * adv_batch
                surr2 = torch.clamp(ratio, 1.0 - self.clip, 1.0 + self.clip) * adv_batch
                loss_actor = -torch.min(surr1, surr2).mean()
                loss_critic = 0.5 * ((valpred.squeeze() - ret_batch) ** 2).mean()
                loss_entropy = -0.01 * dist.entropy().mean()
                loss = loss_actor + loss_critic + loss_entropy

                self.optim.zero_grad()
                loss.backward()
                torch.nn.utils.clip_grad_norm_(self.model.parameters(), 0.5)
                self.optim.step()

        return self.episode_rewards[-1]


def calculate_straightness_metrics(trajectory):
    """è®¡ç®—ç›´çº¿åº¦æŒ‡æ ‡"""
    if len(trajectory) < 2:
        return 0.0, 0.0, 0.0

    x_coords = trajectory[:, 0]
    lateral_deviations = np.abs(x_coords)

    mean_deviation = np.mean(lateral_deviations[10:])
    max_deviation = np.max(lateral_deviations[10:])

    forward_distance = abs(trajectory[-1, 1] - trajectory[0, 1])

    return mean_deviation, max_deviation, forward_distance


def create_animation(env, model, filename):
    obs, _ = env.reset()
    positions = []
    segments_hist = []
    frames = env.max_steps

    for i in range(frames):
        action, _ = model.get_action(obs, deterministic=True)
        obs, _, done, _, _ = env.step(action)
        positions.append(env.body_center.copy())
        segs, _ = env.get_body_segments()
        segments_hist.append(segs)
        if done:
            break

    positions = np.array(positions)

    fig, ax = plt.subplots(figsize=(8, 14))
    ax.set_facecolor('#f7fbff')

    y_max = max(10.0, positions[-1, 1] + 1.0) if len(positions) > 0 else 10.0
    ax.set_xlim(-1.5, 1.5)
    ax.set_ylim(-y_max, 2)

    def update(frame):
        ax.clear()

        # ç»˜åˆ¶ç›®æ ‡ç›´çº¿å’ŒåŒºåŸŸ
        ax.axvline(x=0.0, color='g', linestyle='--', linewidth=2, label='Target Line')
        ax.axvspan(-0.1, 0.1, alpha=0.2, color='green', label='Perfect Zone')
        ax.axvspan(-0.3, -0.1, alpha=0.1, color='yellow')
        ax.axvspan(0.1, 0.3, alpha=0.1, color='yellow')

        # ç»˜åˆ¶è½¨è¿¹
        if frame > 2:
            traj = positions[:frame+1]
            ax.plot(traj[:, 0], traj[:, 1], 'b-', linewidth=2.0, alpha=0.7, label='Trajectory')

        # ç»˜åˆ¶é±¼ä½“
        if frame < len(segments_hist):
            segs = segments_hist[frame]
            colors = plt.cm.Blues(np.linspace(0.4, 0.9, len(segs)))
            for i, seg in enumerate(segs):
                ax.add_patch(Polygon(seg, facecolor=colors[i], edgecolor='navy', linewidth=1.5))

        ax.set_aspect('equal')
        ax.grid(True, alpha=0.3, linestyle='--')
        ax.legend(loc='upper right')

        if frame < len(positions):
            current_x = positions[frame, 0]
            current_y = positions[frame, 1]
            ax.set_title(f"Straight Line Swimming\nStep {frame+1}/{frames}\nX={current_x:.3f}m, Y={current_y:.3f}m",
                         fontsize=11)

        ax.set_xlim(-1.5, 1.5)
        ax.set_ylim(-y_max, 2)
        return []

    anim = animation.FuncAnimation(fig, update, frames=len(positions), interval=50, blit=True)
    anim.save(filename, writer='pillow', fps=20)
    plt.close()
    print(f"Animation saved to {filename}")


def plot_training_results(trainer, results, checkpoints):
    """ç”Ÿæˆè®­ç»ƒæ•ˆæœå¯è§†åŒ–å›¾è¡¨"""

    # å›¾1: è®­ç»ƒæ›²çº¿
    plt.figure(figsize=(12, 5))

    plt.subplot(1, 2, 1)
    rewards = trainer.episode_rewards
    episodes = range(1, len(rewards) + 1)
    plt.plot(episodes, rewards, alpha=0.3, color='steelblue', linewidth=0.5)

    window = 20
    if len(rewards) >= window:
        moving_avg = np.convolve(rewards, np.ones(window)/window, mode='valid')
        plt.plot(range(window, len(rewards)+1), moving_avg,
                color='darkblue', linewidth=2, label=f'{window}-Episode Moving Average')

    for cp in checkpoints:
        if cp <= len(rewards):
            plt.axvline(x=cp, color='red', linestyle='--', alpha=0.5, linewidth=1)
            plt.text(cp, plt.ylim()[1]*0.95, f'CP{cp}',
                    rotation=90, verticalalignment='top', fontsize=8)

    plt.xlabel('Episode', fontsize=11)
    plt.ylabel('Total Reward', fontsize=11)
    plt.title('Training Progress: Episode Rewards', fontsize=12, fontweight='bold')
    plt.grid(True, alpha=0.3)
    plt.legend()

    plt.subplot(1, 2, 2)
    last_50 = rewards[-50:] if len(rewards) >= 50 else rewards
    plt.hist(last_50, bins=20, color='steelblue', alpha=0.7, edgecolor='black')
    plt.axvline(x=np.mean(last_50), color='red', linestyle='--',
                linewidth=2, label=f'Mean: {np.mean(last_50):.1f}')
    plt.xlabel('Episode Reward', fontsize=11)
    plt.ylabel('Frequency', fontsize=11)
    plt.title('Reward Distribution (Last 50 Episodes)', fontsize=12, fontweight='bold')
    plt.legend()
    plt.grid(True, alpha=0.3, axis='y')

    plt.tight_layout()
    plt.savefig('outputs/straight_fig1_training_curve.png', dpi=150, bbox_inches='tight')
    plt.close()
    print("âœ“ Figure 1 saved: outputs/straight_fig1_training_curve.png")


    # å›¾2: æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))

    cps = list(results.keys())
    mean_devs = [results[cp]['mean_deviation'] for cp in cps]
    max_devs = [results[cp]['max_deviation'] for cp in cps]
    forward_dists = [results[cp]['forward_distance'] for cp in cps]

    ax1 = axes[0]
    bars1 = ax1.bar(range(len(cps)), mean_devs, color='coral', alpha=0.8, edgecolor='black')
    ax1.axhline(y=0.15, color='green', linestyle='--', linewidth=2, label='Target: <0.15m')
    ax1.set_xlabel('Training Episodes', fontsize=11)
    ax1.set_ylabel('Mean Lateral Deviation (m)', fontsize=11)
    ax1.set_title('Average Deviation from Center Line', fontsize=12, fontweight='bold')
    ax1.set_xticks(range(len(cps)))
    ax1.set_xticklabels([f'EP{cp}' for cp in cps])
    ax1.legend()
    ax1.grid(True, alpha=0.3, axis='y')

    for i, (bar, val) in enumerate(zip(bars1, mean_devs)):
        height = bar.get_height()
        ax1.text(bar.get_x() + bar.get_width()/2., height,
                f'{val:.3f}m', ha='center', va='bottom', fontsize=9)

    ax2 = axes[1]
    bars2 = ax2.bar(range(len(cps)), max_devs, color='skyblue', alpha=0.8, edgecolor='black')
    ax2.axhline(y=0.3, color='orange', linestyle='--', linewidth=2, label='Target: <0.3m')
    ax2.set_xlabel('Training Episodes', fontsize=11)
    ax2.set_ylabel('Max Lateral Deviation (m)', fontsize=11)
    ax2.set_title('Maximum Deviation from Center Line', fontsize=12, fontweight='bold')
    ax2.set_xticks(range(len(cps)))
    ax2.set_xticklabels([f'EP{cp}' for cp in cps])
    ax2.legend()
    ax2.grid(True, alpha=0.3, axis='y')

    for i, (bar, val) in enumerate(zip(bars2, max_devs)):
        height = bar.get_height()
        ax2.text(bar.get_x() + bar.get_width()/2., height,
                f'{val:.3f}m', ha='center', va='bottom', fontsize=9)

    ax3 = axes[2]
    bars3 = ax3.bar(range(len(cps)), forward_dists, color='lightgreen', alpha=0.8, edgecolor='black')
    ax3.axhline(y=5.0, color='blue', linestyle='--', linewidth=2, label='Target: >5.0m')
    ax3.set_xlabel('Training Episodes', fontsize=11)
    ax3.set_ylabel('Forward Distance (m)', fontsize=11)
    ax3.set_title('Swimming Distance Achieved', fontsize=12, fontweight='bold')
    ax3.set_xticks(range(len(cps)))
    ax3.set_xticklabels([f'EP{cp}' for cp in cps])
    ax3.legend()
    ax3.grid(True, alpha=0.3, axis='y')

    for i, (bar, val) in enumerate(zip(bars3, forward_dists)):
        height = bar.get_height()
        ax3.text(bar.get_x() + bar.get_width()/2., height,
                f'{val:.2f}m', ha='center', va='bottom', fontsize=9)

    plt.tight_layout()
    plt.savefig('outputs/straight_fig2_performance_metrics.png', dpi=150, bbox_inches='tight')
    plt.close()
    print("âœ“ Figure 2 saved: outputs/straight_fig2_performance_metrics.png")


    # å›¾3: è½¨è¿¹å¯¹æ¯”
    fig, axes = plt.subplots(1, 2, figsize=(14, 10))

    # æ—©æœŸæ¨¡å‹
    early_env = StraightLineFishEnv(num_segments=5, body_length=0.8)
    early_trajectories = []
    for _ in range(3):
        obs, _ = early_env.reset()
        for _ in range(300):
            action = early_env.action_space.sample() * 0.3
            obs, _, done, truncated, _ = early_env.step(action)
            if done or truncated:
                break
        early_trajectories.append(early_env.get_trajectory())

    # æœ€ç»ˆæ¨¡å‹
    final_env = StraightLineFishEnv(num_segments=5, body_length=0.8)
    final_trajectories = []
    for _ in range(3):
        obs, _ = final_env.reset()
        for _ in range(500):
            action, _ = trainer.model.get_action(obs, deterministic=True)
            obs, _, done, truncated, _ = final_env.step(action)
            if done or truncated:
                break
        final_trajectories.append(final_env.get_trajectory())

    # ç»˜åˆ¶æ—©æœŸè½¨è¿¹
    ax1 = axes[0]
    colors_early = ['#ff6b6b', '#ee5a6f', '#c44569']
    for i, traj in enumerate(early_trajectories):
        ax1.plot(traj[:, 0], traj[:, 1], color=colors_early[i],
                linewidth=2, alpha=0.7, label=f'Trial {i+1}')

    ax1.axvline(x=0.0, color='green', linestyle='--', linewidth=2, label='Target Line')
    ax1.axvspan(-0.1, 0.1, alpha=0.2, color='green', label='Perfect Zone')
    ax1.axvspan(-0.3, -0.1, alpha=0.1, color='yellow')
    ax1.axvspan(0.1, 0.3, alpha=0.1, color='yellow')
    ax1.set_xlim(-1.0, 1.0)
    ax1.set_ylim(-12, 1.0)
    ax1.set_xlabel('X Position (m)', fontsize=11)
    ax1.set_ylabel('Y Position (m)', fontsize=11)
    ax1.set_title('Early Training (Random Policy)', fontsize=12, fontweight='bold')
    ax1.legend(loc='upper right', fontsize=9)
    ax1.grid(True, alpha=0.3)
    ax1.set_aspect('equal', adjustable='box')

    # ç»˜åˆ¶æœ€ç»ˆè½¨è¿¹
    ax2 = axes[1]
    colors_final = ['#4ecdc4', '#45b7d1', '#3d8bae']
    for i, traj in enumerate(final_trajectories):
        ax2.plot(traj[:, 0], traj[:, 1], color=colors_final[i],
                linewidth=2, alpha=0.7, label=f'Trial {i+1}')

    ax2.axvline(x=0.0, color='green', linestyle='--', linewidth=2, label='Target Line')
    ax2.axvspan(-0.1, 0.1, alpha=0.2, color='green', label='Perfect Zone')
    ax2.axvspan(-0.3, -0.1, alpha=0.1, color='yellow')
    ax2.axvspan(0.1, 0.3, alpha=0.1, color='yellow')
    ax2.set_xlim(-1.0, 1.0)
    ax2.set_ylim(-12, 1.0)
    ax2.set_xlabel('X Position (m)', fontsize=11)
    ax2.set_ylabel('Y Position (m)', fontsize=11)
    ax2.set_title(f'Final Training (EP{checkpoints[-1]})', fontsize=12, fontweight='bold')
    ax2.legend(loc='upper right', fontsize=9)
    ax2.grid(True, alpha=0.3)
    ax2.set_aspect('equal', adjustable='box')

    plt.tight_layout()
    plt.savefig('outputs/straight_fig3_trajectory_comparison.png', dpi=150, bbox_inches='tight')
    plt.close()
    print("âœ“ Figure 3 saved: outputs/straight_fig3_trajectory_comparison.png")


def main():
    print()

    env = StraightLineFishEnv(num_segments=5, body_length=0.8)
    trainer = PPOTrainer(env, lr=3e-4, epochs=10, batch_size=64)

    checkpoints = [5, 30, 50, 100, 150, 300]
    results = {}

    for i, cp in enumerate(checkpoints):
        to_train = cp if i == 0 else (cp - checkpoints[i-1])
        print(f"\n{'='*60}")
        print(f"Training for {to_train} episodes (Total: {cp})")
        print(f"{'='*60}")

        for ep in range(to_train):
            reward = trainer.train_episode()
            if (ep + 1) % 10 == 0:
                recent_rewards = trainer.episode_rewards[-10:]
                avg = np.mean(recent_rewards)
                std = np.std(recent_rewards)
                print(f"Ep {len(trainer.episode_rewards):4d}: avg={avg:7.2f}, std={std:6.2f}, cur={reward:7.2f}")

        gif = f'outputs/fish_straight_improved_ep_{cp}.gif'
        print(f"\nGenerating animation: {gif}")
        anim_env = StraightLineFishEnv(num_segments=5, body_length=0.8)
        create_animation(anim_env, trainer.model, gif)

        print("\nTesting straightness metrics...")
        mean_devs, max_devs, forward_dists = [], [], []

        for test_id in range(5):
            test_env = StraightLineFishEnv(num_segments=5, body_length=0.8)
            obs, _ = test_env.reset()
            for _ in range(500):
                action, _ = trainer.model.get_action(obs, deterministic=True)
                obs, _, done, truncated, _ = test_env.step(action)
                if done or truncated:
                    break

            traj = test_env.get_trajectory()
            mean_dev, max_dev, forward_dist = calculate_straightness_metrics(traj)
            mean_devs.append(mean_dev)
            max_devs.append(max_dev)
            forward_dists.append(forward_dist)

        results[cp] = {
            'mean_deviation': float(np.mean(mean_devs)),
            'max_deviation': float(np.mean(max_devs)),
            'forward_distance': float(np.mean(forward_dists))
        }

        print(f"\nâœ“ Checkpoint {cp} Results:")
        print(f"  å¹³å‡æ¨ªå‘åå·®: {results[cp]['mean_deviation']:.3f}m")
        print(f"  æœ€å¤§æ¨ªå‘åå·®: {results[cp]['max_deviation']:.3f}m")
        print(f"  å‰è¿›è·ç¦»: {results[cp]['forward_distance']:.3f}m")

    print("\n" + "="*60)
    print("=== æœ€ç»ˆè®­ç»ƒç»“æœæ€»ç»“ ===")
    print("="*60)
    for cp, res in results.items():
        print(f"Checkpoint {cp:3d}:")
        print(f"  å¹³å‡æ¨ªå‘åå·®: {res['mean_deviation']:.3f}m (ç›®æ ‡: <0.15m)")
        print(f"  æœ€å¤§æ¨ªå‘åå·®: {res['max_deviation']:.3f}m (ç›®æ ‡: <0.3m)")
        print(f"  å‰è¿›è·ç¦»: {res['forward_distance']:.3f}m (ç›®æ ‡: >5.0m)")
        print()

    print("="*60)
    print("è®­ç»ƒå®Œæˆï¼")
    print("="*60)

    final_result = results[checkpoints[-1]]
    if final_result['forward_distance'] > 5.0 and final_result['mean_deviation'] < 0.15:
        print("\nâœ… ä¼˜ç§€ï¼æœºå™¨é±¼èƒ½ä¿æŒå®Œç¾ç›´çº¿æ¸¸åŠ¨ï¼")
    elif final_result['forward_distance'] > 3.0 and final_result['mean_deviation'] < 0.3:
        print("\nâœ“ è‰¯å¥½ï¼æœºå™¨é±¼èƒ½è¾ƒå¥½åœ°ä¿æŒç›´çº¿æ¸¸åŠ¨ã€‚")
    elif final_result['forward_distance'] > 1.0:
        print("\nâš ï¸  ä¸€èˆ¬ã€‚æœºå™¨é±¼èƒ½å‰è¿›ä½†åç¦»è¾ƒå¤šã€‚")
    else:
        print("\nâŒ éœ€è¦è¿›ä¸€æ­¥è°ƒæ•´å‚æ•°ã€‚")

    return trainer, results, checkpoints


if __name__ == "__main__":
    trainer, results, checkpoints = main()

    # ç”Ÿæˆå¯è§†åŒ–å›¾è¡¨
    print("\n" + "="*60)
    print("ç”Ÿæˆè®­ç»ƒæ•ˆæœå¯è§†åŒ–å›¾è¡¨...")
    print("="*60)
    plot_training_results(trainer, results, checkpoints)

    print("\n" + "="*60)
    print("âœ… æ‰€æœ‰å¯è§†åŒ–å›¾è¡¨å·²ç”Ÿæˆï¼")
    print("="*60)
    print("ç”Ÿæˆçš„æ–‡ä»¶ï¼š")
    print("  ğŸ“Š outputs/straight_fig1_training_curve.png (è®­ç»ƒæ›²çº¿)")
    print("  ğŸ“Š outputs/straight_fig2_performance_metrics.png (æ€§èƒ½æŒ‡æ ‡)")
    print("  ğŸ“Š outputs/straight_fig3_trajectory_comparison.png (è½¨è¿¹å¯¹æ¯”)")
    print("  ğŸ¬ outputs/fish_straight_improved_ep_*.gif (åŠ¨ç”»)")
    print("="*60)
